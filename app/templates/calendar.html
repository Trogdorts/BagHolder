{% extends "base.html" %}
{% block content %}
{% set ui_cfg = cfg.get('ui', {}) %}
{% set notes_cfg = cfg.get('notes', {}) %}
{% set show_unrealized_default = show_unrealized_flag if show_unrealized_flag is defined else ui_cfg.get('show_unrealized', True) %}
{% set show_trade_count_badges = show_trade_badges if show_trade_badges is defined else ui_cfg.get('show_trade_count', False) %}
{% set show_text_default = show_text_flag if show_text_flag is defined else ui_cfg.get('show_text', True) %}
{% set show_percentages_default = show_percentages_flag if show_percentages_flag is defined else ui_cfg.get('show_percentages', True) %}
{% set show_weekends = show_weekends_flag if show_weekends_flag is defined else ui_cfg.get('show_weekends', True) %}
{% set show_exclude_controls = show_exclude_controls_flag if show_exclude_controls_flag is defined else ui_cfg.get('show_exclude_controls', True) %}
{% set notes_enabled = notes_enabled_flag if notes_enabled_flag is defined else notes_cfg.get('enabled', True) %}
<div x-data="calendarToolbar({
        showUnrealized: {{ 'true' if show_unrealized_default else 'false' }},
        showExcludeControls: {{ 'true' if show_exclude_controls else 'false' }},
        showPercentages: {{ 'true' if show_percentages_default else 'false' }},
        showWeekends: {{ 'true' if show_weekends else 'false' }},
        showTradeCounts: {{ 'true' if show_trade_count_badges else 'false' }}
      })"
     data-calendar-root="true"
     data-calendar-year="{{ year }}"
     data-calendar-month="{{ '%02d'|format(month) }}"
     class="space-y-4{% if not show_exclude_controls %} hide-exclude-controls{% endif %}{% if not show_percentages_default %} hide-percentages{% endif %}"
     :class="{ 'hide-exclude-controls': !showExcludeControls, 'hide-percentages': !showPercentages }">
<style>
  .toolbar-card {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 0;
    border: none;
    background: none;
    box-shadow: none;
  }

  .toolbar-top {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: stretch;
  }

  .toolbar-heading {
    align-self: center;
    font-size: 1.875rem;
    line-height: 2.25rem;
    font-weight: 600;
    letter-spacing: -0.015em;
    color: #f4f4f5;
    text-align: center;
  }

  @media (min-width: 640px) {
    .toolbar-heading {
      font-size: 2.25rem;
      line-height: 2.5rem;
    }
  }

  .toolbar-actions {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    align-items: center;
    width: 100%;
  }

  .toolbar-nav {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  @media (min-width: 768px) {
    .toolbar-actions {
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
    }
  }

  .toolbar-nav-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 0.9rem;
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #e4e4e7;
    border-radius: 9999px;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  .toolbar-nav-link:hover,
  .toolbar-nav-link:focus-visible {
    background-color: rgba(63, 63, 70, 0.7);
    color: #fafafa;
  }

  .toolbar-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  @media (min-width: 768px) {
    .toolbar-controls {
      margin-left: auto;
      justify-content: flex-end;
    }
  }

  .toolbar-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 0.95rem;
    border-radius: 9999px;
    border: 1px solid rgba(63, 63, 70, 0.75);
    background: rgba(17, 17, 17, 0.85);
    color: #d4d4d8;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
  }

  .toolbar-toggle:hover,
  .toolbar-toggle:focus-visible {
    background: rgba(63, 63, 70, 0.6);
    border-color: rgba(82, 82, 91, 0.85);
    color: #fafafa;
  }

  .toolbar-toggle.is-active {
    background: rgba(99, 102, 241, 0.2);
    border-color: rgba(129, 140, 248, 0.7);
    color: #e0e7ff;
    box-shadow: inset 0 0 0 1px rgba(129, 140, 248, 0.3);
  }

  .toolbar-toggle:focus-visible {
    outline: 2px solid rgba(129, 140, 248, 0.5);
    outline-offset: 2px;
  }

  .toolbar-card .toolbar-toggle span {
    pointer-events: none;
  }

  .day-excluded {
    opacity: 0.4;
  }

  .day-include-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.125rem 0.5rem;
    border-radius: 9999px;
    border: 1px solid #3f3f46;
    background-color: #171717;
    color: #a3a3a3;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, opacity 0.2s ease;
  }

  .day-include-toggle.toggle-excluded {
    background-color: #7f1d1d;
    border-color: #b91c1c;
    color: #fee2e2;
  }

  .day-include-toggle:focus-visible {
    outline: 2px solid #71717a;
    outline-offset: 2px;
  }

  .day-include-toggle:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .hide-exclude-controls .day-include-toggle {
    display: none;
  }

  .hide-percentages [data-day-percent],
  .hide-percentages [data-week-percent],
  .hide-percentages [data-month-percent],
  .hide-percentages [data-rolling-percent],
  .hide-percentages [data-year-percent] {
    display: none !important;
  }

  [data-day-realized-amount],
  [data-day-percent],
  [data-week-percent],
  [data-month-percent],
  [data-rolling-percent],
  [data-year-percent] {
    display: block;
  }
</style>
  <div class="toolbar-card">
    <div class="toolbar-top">
      {% set prev_year = (month == 1) and year-1 or year %}
      {% set prev_month = (month == 1) and 12 or month-1 %}
      {% set next_year = (month == 12) and year+1 or year %}
      {% set next_month = (month == 12) and 1 or month+1 %}
      <div class="toolbar-heading">
        {{ year }}-{{ "%02d"|format(month) }}
      </div>
      <div class="toolbar-actions">
        <nav class="toolbar-nav" aria-label="Calendar navigation">
          <a href="/calendar/{{ prev_year }}/{{ prev_month }}" class="toolbar-nav-link">Prev</a>
          <a href="/calendar/{{ current_year }}/{{ current_month }}" class="toolbar-nav-link">Today</a>
          <a href="/calendar/{{ next_year }}/{{ next_month }}" class="toolbar-nav-link">Next</a>
        </nav>
        <div class="toolbar-controls">
          <button type="button"
                  class="toolbar-toggle"
                  :class="{ 'is-active': !showUnrealized }"
                  @click="toggleUnrealized()"
                  aria-pressed="{{ 'true' if show_unrealized_default else 'false' }}"
                  :aria-pressed="showUnrealized.toString()">
            <span x-text="showUnrealized ? 'Hide unrealized' : 'Show unrealized'">
              {% if show_unrealized_default %}Hide unrealized{% else %}Show unrealized{% endif %}
            </span>
          </button>
          <button type="button"
                  class="toolbar-toggle"
                  :class="{ 'is-active': !showExcludeControls }"
                  @click="toggleExcludeControls()"
                  aria-pressed="{{ 'true' if show_exclude_controls else 'false' }}"
                  :aria-pressed="showExcludeControls.toString()">
            <span x-text="showExcludeControls ? 'Hide exclude' : 'Show exclude'">
              {% if show_exclude_controls %}Hide exclude{% else %}Show exclude{% endif %}
            </span>
          </button>
          <button type="button"
                  class="toolbar-toggle"
                  :class="{ 'is-active': !showPercentages }"
                  @click="togglePercentages()"
                  aria-pressed="{{ 'true' if show_percentages_default else 'false' }}"
                  :aria-pressed="showPercentages.toString()">
            <span x-text="showPercentages ? 'Hide percent' : 'Show percent'">
              {% if show_percentages_default %}Hide percent{% else %}Show percent{% endif %}
            </span>
          </button>
          <button type="button"
                  class="toolbar-toggle"
                  :class="{ 'is-active': showWeekends }"
                  @click="toggleWeekends()"
                  aria-pressed="{{ 'true' if show_weekends else 'false' }}"
                  :aria-pressed="showWeekends.toString()">
            <span x-text="showWeekends ? 'Hide weekends' : 'Show weekends'">
              {% if show_weekends %}Hide weekends{% else %}Show weekends{% endif %}
            </span>
          </button>
          <button type="button"
                  class="toolbar-toggle"
                  :class="{ 'is-active': showTradeCounts }"
                  @click="toggleTradeCounts()"
                  aria-pressed="{{ 'true' if show_trade_count_badges else 'false' }}"
                  :aria-pressed="showTradeCounts.toString()">
            <span x-text="showTradeCounts ? 'Hide trade count' : 'Show trade count'">
              {% if show_trade_count_badges %}Hide trade count{% else %}Show trade count{% endif %}
            </span>
          </button>
        </div>
      </div>
    </div>
  </div>

  {% set day_labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] %}
  {% set visible_day_labels = day_labels if show_weekends else day_labels[:5] %}
  {% set grid_columns = visible_day_labels|length + 1 %}
  <div class="grid gap-2" style="grid-template-columns: repeat({{ grid_columns }}, minmax(0, 1fr));">
    {% for label in visible_day_labels %}
    <div class="text-xs text-neutral-400">{{ label }}</div>
    {% endfor %}
    <div class="text-xs text-neutral-400 text-right">Week</div>
  </div>

  <div class="grid gap-2 mt-2" style="grid-template-columns: repeat({{ grid_columns }}, minmax(0, 1fr));">
  {% for week in weeks %}
    {% for d in week.days %}
      {% if show_weekends or not d.is_weekend %}
      {% set cls = (d.realized > 0) and 'cell-bg-pos' or (d.realized < 0) and 'cell-bg-neg' or 'bg-neutral-900' %}
      {% set day_identifier = d.date.strftime('%Y-%m-%d') %}
      {% set week_key = week.week_year ~ '-' ~ week.week_number %}
      <div class="relative min-h-[7rem] rounded border border-neutral-800 p-2 {{ 'opacity-100' if d.in_month else 'opacity-30' }} {{ cls }} flex flex-col gap-2"
           data-day-cell="{{ day_identifier }}"
           data-day-realized="{{ '%.10g'|format(d.realized) }}"
           data-day-unrealized="{{ '%.10g'|format(d.unrealized) }}"
           data-day-invested="{{ '%.10g'|format(d.invested) }}"
           data-day-has-values="{{ 'true' if d.has_values else 'false' }}"
           data-day-in-month="{{ 'true' if d.in_month else 'false' }}"
           data-day-in-rolling="{{ 'true' if d.in_rolling else 'false' }}"
           data-day-belongs-year="{{ 'true' if d.belongs_to_year else 'false' }}"
           data-week-key="{{ week_key }}"
           data-week-position="{{ loop.index0 }}">
        <div class="flex items-center gap-1 text-xs text-neutral-400">
          <span>{{ d.date.day }}</span>
          {% set trade_button_classes = [
            'relative inline-flex items-center justify-center rounded-full p-1 trade-button focus:outline-none focus-ring-success transition'
          ] %}
          {% if not d.has_trades %}
            {% set trade_button_classes = trade_button_classes + ['icon-translucent'] %}
          {% endif %}
          <button type="button"
                  class="{{ trade_button_classes|join(' ') }}"
                  onclick="openTrades('{{ d.date.strftime('%Y-%m-%d') }}'); return false;"
                  aria-label="View trades">
            <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" aria-hidden="true">
              <circle cx="12" cy="12" r="9" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 7.5h-1.125a1.875 1.875 0 000 3.75h2.25a1.875 1.875 0 010 3.75H12m0-10.5v10.5" />
            </svg>
            <span class="sr-only">View trades</span>
            {% set trade_count = d.trades|length %}
            {% if trade_count %}
              <span class="trade-count-badge absolute -top-1 -right-1 min-w-[1.25rem] rounded-full text-[10px] font-semibold px-1 text-center"
                    x-cloak
                    x-show="showTradeCounts"
                    {% if not show_trade_count_badges %}style="display: none;"{% endif %}>{{ trade_count }}</span>
            {% endif %}
          </button>
        </div>

        {% if show_text_default %}
        <div class="text-sm space-y-1">
          {% set realized_class = 'text-profit' if d.realized > 0 else ('text-loss' if d.realized < 0 else 'text-neutral-200') %}
            {% if d.show_realized %}
          {% set day_percent_class = 'text-neutral-200' %}
          {% if d.percent is not none %}
            {% if d.percent > 0 %}
              {% set day_percent_class = 'text-profit' %}
            {% elif d.percent < 0 %}
              {% set day_percent_class = 'text-loss' %}
            {% endif %}
          {% endif %}
          <div class="{{ realized_class }} space-y-1">
            <span class="{{ realized_class }}" data-day-realized-amount data-has-percent="{{ 'true' if d.percent is not none else 'false' }}">Realized: {{ d.realized|money }}</span>
            <span data-day-percent class="text-[11px] text-neutral-200{% if d.percent is none %} hidden{% endif %} mt-0.5">Realized: <span data-day-percent-value class="{{ day_percent_class }}">{{ '{:+.2f}%'.format(d.percent) if d.percent is not none else '' }}</span></span>
          </div>
          {% endif %}
          <div class="{{ 'text-profit' if d.unrealized > 0 else ('text-loss' if d.unrealized < 0 else 'text-neutral-200') }}"
               x-show="showUnrealized" x-cloak>
            Unrealized: {{ d.unrealized|money }}
          </div>
        </div>
        {% endif %}

        <!-- Gear icon for manual entry -->
        <a class="absolute top-1 right-1 icon-translucent z-10" href="#"
           aria-label="Edit daily values"
           onclick="openManual('{{ d.date.strftime('%Y-%m-%d') }}', {{ d.realized }}, {{ d.unrealized }}); return false;">
          <svg class="w-4 h-4 action-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M19.14,12.94a7.43,7.43,0,0,0,.05-.94,7.43,7.43,0,0,0-.05-.94l2.11-1.65a.5.5,0,0,0,.12-.64l-2-3.46a.5.5,0,0,0-.6-.22l-2.49,1a7.3,7.3,0,0,0-1.63-.94l-.38-2.65A.5.5,0,0,0,12.64,1H9.36a.5.5,0,0,0-.49.41L8.49,4.06a7.3,7.3,0,0,0-1.63.94l-2.49-1a.5.5,0,0,0-.6.22l-2,3.46a.5.5,0,0,0,.12.64L3.94,11.06a7.43,7.43,0,0,0-.05.94,7.43,7.43,0,0,0,.05.94L1.83,14.59a.5.5,0,0,0-.12.64l2,3.46a.5.5,0,0,0,.6.22l2.49-1a7.3,7.3,0,0,0,1.63.94l.38,2.65a.5.5,0,0,0,.49.41h3.28a.5.5,0,0,0,.49-.41l.38-2.65a7.3,7.3,0,0,0,1.63-.94l2.49,1a.5.5,0,0,0,.6-.22l2-3.46a.5.5,0,0,0-.12-.64Zm-7.14,2.56A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" fill="currentColor" />
          </svg>
        </a>
        <div class="mt-auto flex items-center gap-2">
          <button type="button"
                  class="day-include-toggle"
                  data-day-toggle="{{ day_identifier }}"
                  {% if not d.in_month %}disabled{% endif %}
                  aria-pressed="true">
            Include
          </button>
          {% if notes_enabled %}
          <!-- Note icon -->
          <a class="note-trigger relative inline-flex items-center justify-center ml-auto icon-translucent z-10{% if d.has_note %} has-note{% endif %}"
             href="#"
             aria-label="{{ 'Edit daily note' if d.has_note else 'Add daily note' }}"
             data-note-text="{{ d.note | e }}"
             data-note-updated="{{ d.note_updated_at | default('', true) }}"
             data-note-label-empty="Add daily note"
             data-note-label-filled="Edit daily note"
             onclick="openDailyNote('{{ d.date.strftime('%Y-%m-%d') }}'); return false;">
            <svg class="w-4 h-4 action-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M19 3H5a2 2 0 0 0-2 2v14l4-4h12a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z" fill="currentColor" />
            </svg>
            <div class="note-tooltip absolute bottom-7 right-0 z-20 w-[min(18rem,calc(100vw-2rem))] rounded-lg border border-neutral-800 bg-neutral-950 p-3 text-left text-sm text-neutral-100 shadow-xl ring-1 ring-black/40">
              <div class="flex flex-col gap-2">
                <div>
                  <p class="text-[10px] uppercase tracking-wide text-neutral-500">Daily note</p>
                  <p class="text-[11px] text-neutral-400" data-note-tooltip-updated>Not saved yet</p>
                </div>
                <div class="max-h-48 overflow-y-auto whitespace-pre-wrap break-words leading-relaxed" data-note-tooltip-body>{{ d.note | e }}</div>
              </div>
            </div>
          </a>
          {% endif %}
        </div>
      </div>
    {% endif %}
  {% endfor %}
  {% set week_key = week.week_year ~ '-' ~ week.week_number %}
  {% set week_cls = (week.week_realized > 0) and 'cell-bg-pos' or (week.week_realized < 0) and 'cell-bg-neg' or 'bg-neutral-900' %}
  <div class="relative min-h-[7rem] rounded border border-neutral-800 p-2 flex flex-col justify-between {{ week_cls }}"
       data-week-summary="{{ week_key }}">
    <div>
      <div class="text-xs text-neutral-400">Week {{ week.week_index }}</div>
      <div class="mt-2 text-sm space-y-1 text-right">
        <div data-week-realized
             class="{{ 'text-profit' if week.week_realized > 0 else ('text-loss' if week.week_realized < 0 else 'text-neutral-200') }}{% if not week.show_week_realized %} hidden{% endif %}">
          <div>Realized: <span data-week-realized-value>{{ week.week_realized|money }}</span></div>
          {% set week_percent_class = 'text-neutral-200' %}
          {% if week.week_percent is not none %}
            {% if week.week_percent > 0 %}
              {% set week_percent_class = 'text-profit' %}
            {% elif week.week_percent < 0 %}
              {% set week_percent_class = 'text-loss' %}
            {% endif %}
          {% endif %}
          <div data-week-percent class="text-[11px] text-neutral-200{% if not (show_percentages_default and week.week_percent is not none) %} hidden{% endif %} mt-0.5">
            {% if show_percentages_default and week.week_percent is not none %}Realized: <span data-week-percent-value class="{{ week_percent_class }}">{{ '{:+.2f}%'.format(week.week_percent) }}</span>{% endif %}
          </div>
        </div>
        <div data-week-unrealized
             class="{{ 'text-profit' if week.week_unrealized > 0 else ('text-loss' if week.week_unrealized < 0 else 'text-neutral-200') }}"
             x-show="showUnrealized" x-cloak>
          Unrealized: <span data-week-unrealized-value>{{ week.week_unrealized|money }}</span>
        </div>
      </div>
    </div>
    {% if notes_enabled %}
    <div class="flex justify-end">
      <a class="note-trigger weekly-note-trigger z-10{% if week.has_note %} has-note{% else %} icon-translucent{% endif %}" href="#"
         aria-label="{{ 'Edit weekly note' if week.has_note else 'Add weekly note' }}"
         data-week-year="{{ week.week_year }}"
         data-week-index="{{ week.week_number }}"
         data-note-text="{{ week.note | default('', true) | e }}"
         data-note-updated="{{ week.note_updated_at | default('', true) }}"
         data-note-label-empty="Add weekly note"
         data-note-label-filled="Edit weekly note"
         onclick="openWeeklyNote({{ week.week_year }}, {{ week.week_number }}); return false;">
        <svg class="w-4 h-4 action-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M19 3H5a2 2 0 0 0-2 2v14l4-4h12a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z" fill="currentColor" />
        </svg>
        <div class="note-tooltip absolute bottom-7 right-0 z-20 w-[min(18rem,calc(100vw-2rem))] rounded-lg border border-neutral-800 bg-neutral-950 p-3 text-left text-sm text-neutral-100 shadow-xl ring-1 ring-black/40">
          <div class="flex flex-col gap-2">
            <div>
              <p class="text-[10px] uppercase tracking-wide text-neutral-500">Weekly note</p>
              <p class="text-[11px] text-neutral-400" data-note-tooltip-updated>Not saved yet</p>
            </div>
            <div class="max-h-48 overflow-y-auto whitespace-pre-wrap break-words leading-relaxed" data-note-tooltip-body>{{ week.note | default('', true) | e }}</div>
          </div>
        </div>
      </a>
    </div>
    {% endif %}
  </div>
{% endfor %}
</div>

<div class="mt-6 max-w-3xl">
  <div class="grid gap-4 sm:grid-cols-2">
    <div class="rounded border border-neutral-800 p-3 bg-neutral-950 relative"
         data-month-summary
         data-base-realized="{{ '%.10g'|format(month_realized) }}"
         data-base-unrealized="{{ '%.10g'|format(month_unrealized) }}">
      <h2 class="font-semibold">Monthly summary</h2>
      <div class="space-y-1">
        <div>Realized: <span data-month-realized-value class="{{ 'text-profit' if month_realized > 0 else ('text-loss' if month_realized < 0 else 'text-neutral-200') }}">{{ month_realized|money }}</span></div>
        {% set month_percent_class = 'text-neutral-200' %}
        {% if month_percent is not none %}
          {% if month_percent > 0 %}
            {% set month_percent_class = 'text-profit' %}
          {% elif month_percent < 0 %}
            {% set month_percent_class = 'text-loss' %}
          {% endif %}
        {% endif %}
        <div data-month-percent class="text-[12px]{% if not (show_percentages_default and month_percent is not none) %} hidden{% endif %}">
          {% if show_percentages_default and month_percent is not none %}Realized: <span data-month-percent-value class="{{ month_percent_class }}">{{ '{:+.2f}%'.format(month_percent) }}</span>{% endif %}
        </div>
      </div>
      <div class="mt-2 text-sm hidden" data-month-average>
        <span class="text-neutral-300">Avg realized per day (<span data-month-average-count>0</span> days):</span>
        <span data-month-average-value class="text-neutral-200"></span>
      </div>
      <div x-show="showUnrealized" x-cloak>
        Unrealized (invested): <span data-month-unrealized-value class="{{ 'text-profit' if month_unrealized > 0 else ('text-loss' if month_unrealized < 0 else 'text-neutral-200') }}">{{ month_unrealized|money }}</span>
      </div>
        {% set month_note_text = month_note.note | default('', true) %}
        {% set month_note_has = month_note_text.strip() %}
        {% if notes_enabled %}
        <a class="note-trigger absolute top-1 right-1 z-10{% if month_note_has %} has-note{% else %} icon-translucent{% endif %}" href="#"
           aria-label="{{ 'Edit monthly note' if month_note_has else 'Add monthly note' }}"
           data-month-key="{{ year }}-{{ '%02d'|format(month) }}"
           data-note-text="{{ month_note_text | e }}"
           data-note-updated="{{ month_note.updated_at | default('', true) }}"
           data-note-label-empty="Add monthly note"
           data-note-label-filled="Edit monthly note"
           onclick="openMonthlyNote({{ year }}, {{ month }}); return false;">
          <svg class="w-4 h-4 action-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M19 3H5a2 2 0 0 0-2 2v14l4-4h12a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z" fill="currentColor" />
          </svg>
          <div class="note-tooltip absolute bottom-7 right-0 z-20 w-[min(18rem,calc(100vw-2rem))] rounded-lg border border-neutral-800 bg-neutral-950 p-3 text-left text-sm text-neutral-100 shadow-xl ring-1 ring-black/40">
            <div class="flex flex-col gap-2">
              <div>
                <p class="text-[10px] uppercase tracking-wide text-neutral-500">Monthly note</p>
                <p class="text-[11px] text-neutral-400" data-note-tooltip-updated>Not saved yet</p>
              </div>
              <div class="max-h-48 overflow-y-auto whitespace-pre-wrap break-words leading-relaxed" data-note-tooltip-body>{{ month_note_text | e }}</div>
            </div>
          </div>
        </a>
        {% endif %}
    </div>
    <div class="rounded border border-neutral-800 p-3 bg-neutral-950">
      <h2 class="font-semibold">Yearly summary</h2>
      <div class="mt-2 space-y-4 text-sm">
        <div class="space-y-1"
             data-rolling-summary
             data-base-realized="{{ '%.10g'|format(rolling_year_realized) }}"
             data-base-unrealized="{{ '%.10g'|format(rolling_year_unrealized) }}"
             data-base-trading-days="{{ rolling_year_trading_days }}"
             data-other-invested-max="{{ '%.10g'|format(rolling_year_other_invested_max) }}">
          <p class="text-[11px] uppercase tracking-wide text-neutral-400">Last 12 months</p>
          <div>Realized: <span data-rolling-realized-value class="{{ 'text-profit' if rolling_year_realized > 0 else ('text-loss' if rolling_year_realized < 0 else 'text-neutral-200') }}">{{ rolling_year_realized|money }}</span></div>
          {% set rolling_percent_class = 'text-neutral-200' %}
          {% if rolling_year_percent is not none %}
            {% if rolling_year_percent > 0 %}
              {% set rolling_percent_class = 'text-profit' %}
            {% elif rolling_year_percent < 0 %}
              {% set rolling_percent_class = 'text-loss' %}
            {% endif %}
          {% endif %}
          <div data-rolling-percent class="text-[12px]{% if not (show_percentages_default and rolling_year_percent is not none) %} hidden{% endif %}">
            {% if show_percentages_default and rolling_year_percent is not none %}Realized: <span data-rolling-percent-value class="{{ rolling_percent_class }}">{{ '{:+.2f}%'.format(rolling_year_percent) }}</span>{% endif %}
          </div>
          <div class="text-sm hidden" data-rolling-average>
            <span class="text-neutral-300">Avg realized per day (<span data-rolling-average-count>0</span> days):</span>
            <span data-rolling-average-value class="text-neutral-200"></span>
          </div>
          <div x-show="showUnrealized" x-cloak>
            Unrealized (invested): <span data-rolling-unrealized-value class="{{ 'text-profit' if rolling_year_unrealized > 0 else ('text-loss' if rolling_year_unrealized < 0 else 'text-neutral-200') }}">{{ rolling_year_unrealized|money }}</span>
          </div>
        </div>
        <div class="space-y-1"
             data-year-summary
             data-base-realized="{{ '%.10g'|format(year_realized) }}"
             data-base-unrealized="{{ '%.10g'|format(year_unrealized) }}"
             data-base-trading-days="{{ year_trading_days }}"
             data-other-invested-max="{{ '%.10g'|format(year_other_invested_max) }}">
          <p class="text-[11px] uppercase tracking-wide text-neutral-400">Since Jan 1</p>
          <div>Realized: <span data-year-realized-value class="{{ 'text-profit' if year_realized > 0 else ('text-loss' if year_realized < 0 else 'text-neutral-200') }}">{{ year_realized|money }}</span></div>
          {% set year_percent_class = 'text-neutral-200' %}
          {% if year_percent is not none %}
            {% if year_percent > 0 %}
              {% set year_percent_class = 'text-profit' %}
            {% elif year_percent < 0 %}
              {% set year_percent_class = 'text-loss' %}
            {% endif %}
          {% endif %}
          <div data-year-percent class="text-[12px]{% if not (show_percentages_default and year_percent is not none) %} hidden{% endif %}">
            {% if show_percentages_default and year_percent is not none %}Realized: <span data-year-percent-value class="{{ year_percent_class }}">{{ '{:+.2f}%'.format(year_percent) }}</span>{% endif %}
          </div>
          <div class="text-sm hidden" data-year-average>
            <span class="text-neutral-300">Avg realized per day (<span data-year-average-count>0</span> days):</span>
            <span data-year-average-value class="text-neutral-200"></span>
          </div>
          <div x-show="showUnrealized" x-cloak>
            Unrealized (invested): <span data-year-unrealized-value class="{{ 'text-profit' if year_unrealized > 0 else ('text-loss' if year_unrealized < 0 else 'text-neutral-200') }}">{{ year_unrealized|money }}</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

</div>

<!-- Modals -->
<div
  id="modal"
  x-data="{
    open: false,
    title: '',
    body: '',
    save: null,
    previouslyFocused: null,
    closeLabel: 'Close',
    saveLabel: 'Save',
    saving: false,
    shouldReloadOnClose: false,
    beforeClose: null,
    init() {
      window.modalController = this;
      this.$watch('open', (value) => {
        document.body.classList.toggle('modal-open', value);
        this.toggleBackgroundInteractivity(value);
        if (value) {
          this.storeActiveElement();
          this.$nextTick(() => this.focusFirstElement());
        } else {
          this.restoreActiveElement();
          this.resetState();
        }
      });
    },
    toggleBackgroundInteractivity(isOpen) {
      const applyState = (element) => {
        if (!element) {
          return;
        }
        element.classList.toggle('modal-background-inert', isOpen);
        if (isOpen) {
          element.setAttribute('aria-hidden', 'true');
        } else {
          element.removeAttribute('aria-hidden');
        }
        if ('inert' in element) {
          element.inert = isOpen;
        }
      };

      applyState(document.querySelector('nav'));

      const main = document.querySelector('main');
      if (!main) {
        return;
      }

      const backgroundElements = Array.from(main.children).filter((child) => child.id !== 'modal');
      backgroundElements.forEach(applyState);
    },
    storeActiveElement() {
      this.previouslyFocused = document.activeElement;
    },
    restoreActiveElement() {
      if (this.previouslyFocused && typeof this.previouslyFocused.focus === 'function') {
        this.previouslyFocused.focus({ preventScroll: true });
      }
      this.previouslyFocused = null;
    },
    focusFirstElement() {
      const dialog = this.$refs.dialog;
      if (!dialog) {
        return;
      }
      const focusable = dialog.querySelector('[data-autofocus], button, textarea, input, select, [tabindex]:not([tabindex=&quot;-1&quot;])');
      if (focusable && typeof focusable.focus === 'function') {
        focusable.focus();
      } else if (typeof dialog.focus === 'function') {
        dialog.focus();
      }
    },
    resetState() {
      this.save = null;
      this.closeLabel = 'Close';
      this.saveLabel = 'Save';
      this.saving = false;
      this.shouldReloadOnClose = false;
      this.beforeClose = null;
    },
    close(force = false) {
      if (!force && typeof this.beforeClose === 'function') {
        try {
          const shouldClose = this.beforeClose();
          if (shouldClose === false) {
            return;
          }
        } catch (error) {
          console.error(error);
          return;
        }
      }
      const reload = this.shouldReloadOnClose;
      this.open = false;
      if (reload) {
        setTimeout(() => window.location.reload(), 0);
      }
    },
  }"
  x-show="open"
  x-cloak
  class="fixed inset-0 z-50 bg-black/60 flex items-center justify-center"
  role="dialog"
  aria-modal="true"
  :aria-hidden="(!open).toString()"
  @click.self="close()"
  @keydown.escape.window.stop.prevent="close()"
>
  <div
    x-ref="dialog"
    class="bg-neutral-950 border border-neutral-800 rounded p-4 w-full max-w-3xl focus:outline-none"
    role="document"
    tabindex="-1"
    @click.stop
  >
    <h3 class="font-semibold mb-2" x-text="title"></h3>
    <div x-html="body"></div>
    <div class="mt-4 flex justify-end gap-2">
      <button type="button" class="px-3 py-1 rounded border border-neutral-700" @click="close()" x-text="closeLabel"></button>
      <button
        type="button"
        class="btn btn-primary px-3 py-1 text-sm"
        :class="{ 'opacity-60 cursor-not-allowed': saving || !save }"
        :disabled="saving || !save"
        @click="if (!saving && save) save()"
      >
        <span x-text="saving ? 'Saving…' : saveLabel"></span>
      </button>
    </div>
  </div>
</div>

</div>

<script>
async function updateUiPreferences(payload) {
  try {
    const response = await fetch('/api/ui/preferences', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload || {}),
    });
    if (!response.ok) {
      let message = 'Failed to save preference.';
      try {
        const data = await response.json();
        if (data && data.detail) {
          message = data.detail;
        }
      } catch (error) {
        // Ignore JSON parse errors and use fallback message
      }
      throw new Error(message);
    }
    return true;
  } catch (error) {
    console.warn('Unable to save preference', error);
    return false;
  }
}

function calendarToolbar(initialState = {}) {
  return {
    showUnrealized: !!initialState.showUnrealized,
    showExcludeControls:
      initialState.showExcludeControls === undefined
        ? true
        : !!initialState.showExcludeControls,
    showPercentages:
      initialState.showPercentages === undefined
        ? true
        : !!initialState.showPercentages,
    showWeekends: !!initialState.showWeekends,
    showTradeCounts:
      initialState.showTradeCounts === undefined
        ? false
        : !!initialState.showTradeCounts,
    async toggleUnrealized() {
      const previous = this.showUnrealized;
      const next = !previous;
      this.showUnrealized = next;
      const saved = await updateUiPreferences({ show_unrealized: next });
      if (!saved) {
        this.showUnrealized = previous;
      }
    },
    async toggleExcludeControls() {
      const previous = this.showExcludeControls;
      const next = !previous;
      this.showExcludeControls = next;
      const saved = await updateUiPreferences({ show_exclude_controls: next });
      if (!saved) {
        this.showExcludeControls = previous;
      }
    },
    async togglePercentages() {
      const previous = this.showPercentages;
      const next = !previous;
      this.showPercentages = next;
      const saved = await updateUiPreferences({ show_percentages: next });
      if (!saved) {
        this.showPercentages = previous;
      }
    },
    async toggleWeekends() {
      const previous = this.showWeekends;
      const next = !previous;
      this.showWeekends = next;
      const saved = await updateUiPreferences({ show_weekends: next });
      if (!saved) {
        this.showWeekends = previous;
        return;
      }
      window.location.reload();
    },
    async toggleTradeCounts() {
      const previous = this.showTradeCounts;
      const next = !previous;
      this.showTradeCounts = next;
      const saved = await updateUiPreferences({ show_trade_count: next });
      if (!saved) {
        this.showTradeCounts = previous;
      }
    },
  };
}

const dayImpactSimulator = (() => {
  const cells = Array.from(document.querySelectorAll('[data-day-cell]'));
  if (!cells.length) {
    return null;
  }

  const parseNumber = (value) => {
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : 0;
    }
    if (typeof value === 'string' && value.trim() !== '') {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : 0;
    }
    return 0;
  };

  const isApproximatelyZero = (value) => Math.abs(value) <= 0.005;

  const formatMoney = (value) => {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) {
      return '$0.00';
    }
    const sign = numeric < 0 ? '-' : '';
    const absolute = Math.abs(numeric);
    return `${sign}$${absolute.toLocaleString(undefined, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })}`;
  };

  const formatPercentage = (value) => {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) {
      return '';
    }
    const rounded = Math.round(numeric * 100) / 100;
    const sign = rounded >= 0 ? '+' : '';
    return `${sign}${rounded.toFixed(2)}%`;
  };

  const calculatePercentageValue = (realized, samples) => {
    const valid = [];
    samples.forEach((sample) => {
      const numeric = Math.abs(Number(sample));
      if (Number.isFinite(numeric) && !isApproximatelyZero(numeric)) {
        valid.push(numeric);
      }
    });
    if (!valid.length) {
      return null;
    }
    const denominator = Math.max(...valid);
    if (!Number.isFinite(denominator) || isApproximatelyZero(denominator)) {
      return null;
    }
    const result = (Number(realized) / denominator) * 100;
    if (!Number.isFinite(result)) {
      return null;
    }
    return Math.round(result * 100) / 100;
  };

  const collectInvestedSample = (collection, value) => {
    const magnitude = Math.abs(Number(value));
    if (!Number.isFinite(magnitude) || isApproximatelyZero(magnitude)) {
      return;
    }
    collection.push(magnitude);
  };

  const calendarRoot = document.querySelector('[data-calendar-root]');
  const calendarYear = calendarRoot ? calendarRoot.dataset.calendarYear : '';
  const calendarMonth = calendarRoot ? calendarRoot.dataset.calendarMonth : '';
  const excludedStorageKey =
    calendarYear && calendarMonth
      ? `bagholder:excludedDays:${calendarYear}-${calendarMonth}`
      : null;

  const loadStoredExcludedDays = () => {
    if (!excludedStorageKey) {
      return new Set();
    }
    try {
      const storage = window.localStorage;
      if (!storage) {
        return new Set();
      }
      const raw = storage.getItem(excludedStorageKey);
      if (!raw) {
        return new Set();
      }
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) {
        return new Set();
      }
      const valid = parsed.filter((value) => typeof value === 'string' && value);
      return new Set(valid);
    } catch (error) {
      console.warn('Unable to restore excluded day selections', error);
      return new Set();
    }
  };

  const excludedDays = loadStoredExcludedDays();

  const persistExcludedDays = () => {
    if (!excludedStorageKey) {
      return;
    }
    try {
      const storage = window.localStorage;
      if (!storage) {
        return;
      }
      storage.setItem(excludedStorageKey, JSON.stringify(Array.from(excludedDays)));
    } catch (error) {
      console.warn('Unable to persist excluded day selections', error);
    }
  };

  const updateExcludedStorage = (dateStr, included) => {
    if (!excludedStorageKey || !dateStr) {
      return;
    }
    if (included) {
      excludedDays.delete(dateStr);
    } else {
      excludedDays.add(dateStr);
    }
    persistExcludedDays();
  };

  const dayMap = new Map();
  const weekStructure = new Map();

  const setDayToggleState = (toggle, included) => {
    if (!toggle) {
      return;
    }
    toggle.classList.toggle('toggle-excluded', !included);
    toggle.setAttribute('aria-pressed', included ? 'true' : 'false');
    toggle.dataset.state = included ? 'included' : 'excluded';
    toggle.textContent = included ? 'Include' : 'Excluded';
  };

  cells.forEach((cell) => {
    const dateStr = cell.dataset.dayCell;
    if (!dateStr) {
      return;
    }
    const day = {
      cell,
      realized: parseNumber(cell.dataset.dayRealized),
      unrealized: parseNumber(cell.dataset.dayUnrealized),
      invested: parseNumber(cell.dataset.dayInvested),
      hasValues: cell.dataset.dayHasValues === 'true',
      inMonth: cell.dataset.dayInMonth === 'true',
      inRolling: cell.dataset.dayInRolling === 'true',
      belongsToYear: cell.dataset.dayBelongsYear === 'true',
      weekKey: cell.dataset.weekKey || '',
      weekPosition: Number(cell.dataset.weekPosition || '0'),
      included: true,
    };
    dayMap.set(dateStr, day);

    if (day.inMonth && excludedDays.has(dateStr)) {
      day.included = false;
    }
    day.dateStr = dateStr;

    if (day.weekKey) {
      if (!weekStructure.has(day.weekKey)) {
        weekStructure.set(day.weekKey, []);
      }
      weekStructure.get(day.weekKey).push({ date: dateStr, position: day.weekPosition });
    }

    const toggle = cell.querySelector('[data-day-toggle]');
    if (toggle) {
      const isDisabled = toggle.disabled;
      setDayToggleState(toggle, day.included);
      const shouldExclude = !day.included && day.inMonth;
      cell.classList.toggle('day-excluded', shouldExclude);
      if (!isDisabled) {
        toggle.addEventListener('click', () => {
          day.included = !day.included;
          setDayToggleState(toggle, day.included);
          const shouldExclude = !day.included && day.inMonth;
          cell.classList.toggle('day-excluded', shouldExclude);
          if (day.inMonth) {
            updateExcludedStorage(dateStr, day.included);
          }
          updateSummaries();
        });
      }
    }
  });

  if (excludedDays.size) {
    const valid = new Set();
    dayMap.forEach((value, key) => {
      if (value.inMonth && excludedDays.has(key)) {
        valid.add(key);
      }
    });
    if (valid.size !== excludedDays.size) {
      excludedDays.clear();
      valid.forEach((key) => excludedDays.add(key));
      persistExcludedDays();
    }
  }

  if (!dayMap.size) {
    return null;
  }

  weekStructure.forEach((entries) => {
    entries.sort((a, b) => a.position - b.position);
  });

  const monthSummaryEl = document.querySelector('[data-month-summary]');
  const monthRealizedEl = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-realized-value]') : null;
  const monthPercentContainer = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-percent]') : null;
  const monthPercentValueEl = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-percent-value]') : null;
  const monthUnrealizedEl = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-unrealized-value]') : null;
  const monthAverageContainer = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-average]') : null;
  const monthAverageCountEl = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-average-count]') : null;
  const monthAverageValueEl = monthSummaryEl ? monthSummaryEl.querySelector('[data-month-average-value]') : null;

  const rollingSummaryEl = document.querySelector('[data-rolling-summary]');
  const rollingRealizedEl = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-realized-value]') : null;
  const rollingPercentContainer = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-percent]') : null;
  const rollingPercentValueEl = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-percent-value]') : null;
  const rollingUnrealizedEl = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-unrealized-value]') : null;
  const rollingAverageContainer = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-average]') : null;
  const rollingAverageCountEl = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-average-count]') : null;
  const rollingAverageValueEl = rollingSummaryEl ? rollingSummaryEl.querySelector('[data-rolling-average-value]') : null;

  const yearSummaryEl = document.querySelector('[data-year-summary]');
  const yearRealizedEl = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-realized-value]') : null;
  const yearPercentContainer = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-percent]') : null;
  const yearPercentValueEl = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-percent-value]') : null;
  const yearUnrealizedEl = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-unrealized-value]') : null;
  const yearAverageContainer = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-average]') : null;
  const yearAverageCountEl = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-average-count]') : null;
  const yearAverageValueEl = yearSummaryEl ? yearSummaryEl.querySelector('[data-year-average-value]') : null;

  const weekSummaries = new Map();
  document.querySelectorAll('[data-week-summary]').forEach((weekEl) => {
    const key = weekEl.dataset.weekSummary;
    if (!key) {
      return;
    }
    weekSummaries.set(key, {
      element: weekEl,
      realizedContainer: weekEl.querySelector('[data-week-realized]'),
      realizedValue: weekEl.querySelector('[data-week-realized-value]'),
      percent: weekEl.querySelector('[data-week-percent]'),
      percentValue: weekEl.querySelector('[data-week-percent-value]'),
      unrealizedContainer: weekEl.querySelector('[data-week-unrealized]'),
      unrealizedValue: weekEl.querySelector('[data-week-unrealized-value]'),
    });
  });

  const yearBaseRealized = parseNumber(yearSummaryEl && yearSummaryEl.dataset.baseRealized);
  const yearBaseUnrealized = parseNumber(yearSummaryEl && yearSummaryEl.dataset.baseUnrealized);
  const yearBaseTradingDays = parseNumber(yearSummaryEl && yearSummaryEl.dataset.baseTradingDays);
  const yearOtherInvestedMax = parseNumber(yearSummaryEl && yearSummaryEl.dataset.otherInvestedMax);
  const rollingBaseRealized = parseNumber(rollingSummaryEl && rollingSummaryEl.dataset.baseRealized);
  const rollingBaseUnrealized = parseNumber(rollingSummaryEl && rollingSummaryEl.dataset.baseUnrealized);
  const rollingBaseTradingDays = parseNumber(rollingSummaryEl && rollingSummaryEl.dataset.baseTradingDays);
  const rollingOtherInvestedMax = parseNumber(rollingSummaryEl && rollingSummaryEl.dataset.otherInvestedMax);

  let monthInitialRealized = 0;
  let monthInitialUnrealized = 0;
  let rollingMonthRealized = 0;
  let rollingMonthUnrealized = 0;
  let monthInitialYearTradingDays = 0;
  let monthInitialRollingTradingDays = 0;

  dayMap.forEach((day) => {
    if (day.inMonth && day.hasValues) {
      monthInitialRealized += day.realized;
      monthInitialUnrealized += day.unrealized;
      if (day.inRolling) {
        rollingMonthRealized += day.realized;
        rollingMonthUnrealized += day.unrealized;
        monthInitialRollingTradingDays += 1;
      }
      if (day.belongsToYear) {
        monthInitialYearTradingDays += 1;
      }
    }
  });

  const yearOtherRealized = yearBaseRealized - monthInitialRealized;
  const yearOtherUnrealized = yearBaseUnrealized - monthInitialUnrealized;
  const rollingOtherRealized = rollingBaseRealized - rollingMonthRealized;
  const rollingOtherUnrealized = rollingBaseUnrealized - rollingMonthUnrealized;
  const yearOtherTradingDays = Math.max(0, yearBaseTradingDays - monthInitialYearTradingDays);
  const rollingOtherTradingDays = Math.max(0, rollingBaseTradingDays - monthInitialRollingTradingDays);

  function applySignClass(element, value) {
    if (!element) {
      return;
    }
    element.classList.remove('text-profit', 'text-loss', 'text-neutral-200');
    if (value > 0.005) {
      element.classList.add('text-profit');
    } else if (value < -0.005) {
      element.classList.add('text-loss');
    } else {
      element.classList.add('text-neutral-200');
    }
  }

  function applyBackgroundClass(element, value) {
    if (!element) {
      return;
    }
    element.classList.remove('cell-bg-pos', 'cell-bg-neg', 'bg-neutral-900');
    if (value > 0.005) {
      element.classList.add('cell-bg-pos');
    } else if (value < -0.005) {
      element.classList.add('cell-bg-neg');
    } else {
      element.classList.add('bg-neutral-900');
    }
  }

  function updateWeekSummary(key, state) {
    const dom = weekSummaries.get(key);
    if (!dom) {
      return;
    }

    const realizedValue = state.hasIncluded ? state.realized : 0;
    if (dom.realizedContainer) {
      const shouldShow = state.hasIncluded && !isApproximatelyZero(realizedValue);
      dom.realizedContainer.classList.toggle('hidden', !shouldShow);
      if (dom.realizedValue) {
        dom.realizedValue.textContent = formatMoney(realizedValue);
      }
      applySignClass(dom.realizedContainer, realizedValue);
      if (dom.percent && dom.percentValue) {
        const percentValue = shouldShow ? calculatePercentageValue(realizedValue, state.investedSamples) : null;
        if (percentValue === null) {
          dom.percent.classList.add('hidden');
          dom.percentValue.textContent = '';
          applySignClass(dom.percentValue, 0);
        } else {
          dom.percent.classList.remove('hidden');
          dom.percentValue.textContent = formatPercentage(percentValue);
          applySignClass(dom.percentValue, percentValue);
        }
      }
    }

    if (dom.unrealizedContainer && dom.unrealizedValue) {
      const unrealizedValue = state.hasIncluded ? state.lastUnrealized : 0;
      dom.unrealizedContainer.classList.toggle('hidden', !state.hasIncluded);
      dom.unrealizedValue.textContent = formatMoney(unrealizedValue);
      applySignClass(dom.unrealizedContainer, unrealizedValue);
    }

    applyBackgroundClass(dom.element, realizedValue);
  }

  function updateSummaries() {
    let monthRealized = 0;
    let monthUnrealized = 0;
    const monthInvestedSamples = [];
    const rollingInvestedSamples = [];
    const yearInvestedSamples = [];
    let monthTradingDays = 0;
    let yearRealized = yearOtherRealized;
    let yearUnrealized = yearOtherUnrealized;
    let yearTradingDays = yearOtherTradingDays;
    let rollingRealized = rollingOtherRealized;
    let rollingUnrealized = rollingOtherUnrealized;
    let rollingTradingDays = rollingOtherTradingDays;

    collectInvestedSample(rollingInvestedSamples, rollingOtherInvestedMax);
    collectInvestedSample(yearInvestedSamples, yearOtherInvestedMax);

    dayMap.forEach((day) => {
      if (!day.included) {
        return;
      }
      if (day.inMonth && day.hasValues) {
        monthRealized += day.realized;
        monthUnrealized += day.unrealized;
        collectInvestedSample(monthInvestedSamples, day.invested);
        monthTradingDays += 1;
      }
      if (day.inMonth && day.hasValues && day.belongsToYear) {
        yearRealized += day.realized;
        yearUnrealized += day.unrealized;
        yearTradingDays += 1;
        collectInvestedSample(yearInvestedSamples, day.invested);
      }
      if (day.inRolling && day.hasValues) {
        rollingRealized += day.realized;
        rollingUnrealized += day.unrealized;
        collectInvestedSample(rollingInvestedSamples, day.invested);
        if (day.inMonth) {
          rollingTradingDays += 1;
        }
      }
    });

    if (monthRealizedEl) {
      monthRealizedEl.textContent = formatMoney(monthRealized);
      applySignClass(monthRealizedEl, monthRealized);
    }
    if (monthPercentContainer && monthPercentValueEl) {
      const percentValue = calculatePercentageValue(monthRealized, monthInvestedSamples);
      if (percentValue === null) {
        monthPercentContainer.classList.add('hidden');
        monthPercentValueEl.textContent = '';
        applySignClass(monthPercentValueEl, 0);
      } else {
        monthPercentContainer.classList.remove('hidden');
        monthPercentValueEl.textContent = formatPercentage(percentValue);
        applySignClass(monthPercentValueEl, percentValue);
      }
    }
    if (monthUnrealizedEl) {
      monthUnrealizedEl.textContent = formatMoney(monthUnrealized);
      applySignClass(monthUnrealizedEl, monthUnrealized);
    }

    if (monthAverageContainer && monthAverageCountEl && monthAverageValueEl) {
      if (monthTradingDays > 0) {
        monthAverageCountEl.textContent = monthTradingDays.toString();
        const averageValue = monthRealized / monthTradingDays;
        monthAverageValueEl.textContent = formatMoney(averageValue);
        applySignClass(monthAverageValueEl, averageValue);
        monthAverageContainer.classList.remove('hidden');
      } else {
        monthAverageContainer.classList.add('hidden');
      }
    }

    if (rollingRealizedEl) {
      rollingRealizedEl.textContent = formatMoney(rollingRealized);
      applySignClass(rollingRealizedEl, rollingRealized);
    }
    if (rollingPercentContainer && rollingPercentValueEl) {
      const percentValue = calculatePercentageValue(rollingRealized, rollingInvestedSamples);
      if (percentValue === null) {
        rollingPercentContainer.classList.add('hidden');
        rollingPercentValueEl.textContent = '';
        applySignClass(rollingPercentValueEl, 0);
      } else {
        rollingPercentContainer.classList.remove('hidden');
        rollingPercentValueEl.textContent = formatPercentage(percentValue);
        applySignClass(rollingPercentValueEl, percentValue);
      }
    }
    if (rollingUnrealizedEl) {
      rollingUnrealizedEl.textContent = formatMoney(rollingUnrealized);
      applySignClass(rollingUnrealizedEl, rollingUnrealized);
    }

    if (rollingAverageContainer && rollingAverageCountEl && rollingAverageValueEl) {
      if (rollingTradingDays > 0) {
        rollingAverageCountEl.textContent = rollingTradingDays.toString();
        const rollingAverage = rollingRealized / rollingTradingDays;
        rollingAverageValueEl.textContent = formatMoney(rollingAverage);
        applySignClass(rollingAverageValueEl, rollingAverage);
        rollingAverageContainer.classList.remove('hidden');
      } else {
        rollingAverageContainer.classList.add('hidden');
      }
    }

    if (yearRealizedEl) {
      yearRealizedEl.textContent = formatMoney(yearRealized);
      applySignClass(yearRealizedEl, yearRealized);
    }
    if (yearPercentContainer && yearPercentValueEl) {
      const percentValue = calculatePercentageValue(yearRealized, yearInvestedSamples);
      if (percentValue === null) {
        yearPercentContainer.classList.add('hidden');
        yearPercentValueEl.textContent = '';
        applySignClass(yearPercentValueEl, 0);
      } else {
        yearPercentContainer.classList.remove('hidden');
        yearPercentValueEl.textContent = formatPercentage(percentValue);
        applySignClass(yearPercentValueEl, percentValue);
      }
    }
    if (yearUnrealizedEl) {
      yearUnrealizedEl.textContent = formatMoney(yearUnrealized);
      applySignClass(yearUnrealizedEl, yearUnrealized);
    }

    if (yearAverageContainer && yearAverageCountEl && yearAverageValueEl) {
      if (yearTradingDays > 0) {
        yearAverageCountEl.textContent = yearTradingDays.toString();
        const yearAverage = yearRealized / yearTradingDays;
        yearAverageValueEl.textContent = formatMoney(yearAverage);
        applySignClass(yearAverageValueEl, yearAverage);
        yearAverageContainer.classList.remove('hidden');
      } else {
        yearAverageContainer.classList.add('hidden');
      }
    }

    weekStructure.forEach((entries, key) => {
      const state = {
        realized: 0,
        investedSamples: [],
        lastUnrealized: 0,
        hasIncluded: false,
      };

      entries.forEach((entry) => {
        const day = dayMap.get(entry.date);
        if (!day || !day.inMonth || !day.included) {
          return;
        }
        if (day.hasValues) {
          state.realized += day.realized;
          collectInvestedSample(state.investedSamples, day.invested);
        }
        state.lastUnrealized = day.unrealized;
        state.hasIncluded = true;
      });

      updateWeekSummary(key, state);
    });
  }

  updateSummaries();

  return {
    update: updateSummaries,
  };
})();

function openTrades(dateStr) {
  fetch('/api/trades/' + dateStr)
    .then(response => {
      if (!response.ok) {
        return response.json().catch(() => ({})).then(data => {
          const message = data && data.detail ? data.detail : 'Failed to load trades.';
          throw new Error(message);
        });
      }
      return response.json();
    })
    .then(js => {
      const modal = getModalController();
      if (!modal) return;
      modal.title = 'Trades ' + dateStr;
      modal.body = createTradeEditorHTML();
      modal.save = () => saveTrades(dateStr);
      modal.open = true;
      setTimeout(() => setupTradeEditor(js.trades || [], dateStr), 0);
    })
    .catch(err => {
      const modal = getModalController();
      if (!modal) return;
      modal.title = 'Trades ' + dateStr;
      modal.body = `<p class="text-sm text-danger">${err.message || 'Failed to load trades.'}</p>`;
      modal.save = null;
      modal.open = true;
    });
}

function createTradeEditorHTML() {
  return `
    <div id="trade-editor" class="space-y-3">
      <p id="trade-error" class="text-sm text-danger hidden"></p>
      <p id="trade-success" class="text-sm text-success hidden"></p>
      <p id="trade-unsaved" class="text-xs text-warning hidden">Unsaved changes. Save your trades to keep them.</p>
      <div id="trade-empty-message" class="text-sm text-neutral-400 hidden">No trades recorded for this date.</div>
      <div class="overflow-x-auto" style="max-height: 20rem; overflow-y: auto;">
        <table class="min-w-full text-sm text-left text-neutral-200 border border-neutral-800">
          <thead class="bg-neutral-900 text-neutral-400">
            <tr>
              <th class="px-2 py-1 border border-neutral-800">Action</th>
              <th class="px-2 py-1 border border-neutral-800">Symbol</th>
              <th class="px-2 py-1 border border-neutral-800 text-right">Quantity</th>
              <th class="px-2 py-1 border border-neutral-800 text-right">Price</th>
              <th class="px-2 py-1 border border-neutral-800 text-right">Actions</th>
            </tr>
          </thead>
          <tbody id="trade-table-body"></tbody>
        </table>
      </div>
      <div class="space-y-2">
        <div class="flex items-center justify-between flex-wrap gap-2">
          <div class="flex items-center gap-2 flex-wrap">
            <button type="button" id="add-trade-row" class="px-3 py-1 rounded border border-neutral-700 hover:bg-neutral-800 text-sm">Add trade</button>
            <button type="button" id="clear-trades" class="btn btn-outline-danger px-3 py-1 text-sm">Clear all trades</button>
          </div>
          <div class="flex items-center gap-2 flex-wrap">
            <input type="file" id="trade-import-input" accept=".csv,text/csv" class="hidden">
            <button type="button" id="export-trades" class="px-3 py-1 rounded border border-neutral-700 hover:bg-neutral-800 text-sm">Export CSV</button>
            <button type="button" id="import-trades" class="btn btn-outline-primary px-3 py-1 text-sm">Import CSV</button>
          </div>
        </div>
        <span class="text-xs text-neutral-500">Remove a row to delete a trade. Amounts are calculated on save.</span>
      </div>
    </div>`;
}

const tradeEditorState = {
  initialSnapshot: '[]',
  isDirty: false,
  unsavedWarning: null,
  currentDate: null,
};

function getTradeEditorWarningElement() {
  if (tradeEditorState.unsavedWarning && document.body && document.body.contains(tradeEditorState.unsavedWarning)) {
    return tradeEditorState.unsavedWarning;
  }
  const element = document.getElementById('trade-unsaved');
  tradeEditorState.unsavedWarning = element || null;
  return tradeEditorState.unsavedWarning;
}

function setTradeEditorDirty(isDirty) {
  tradeEditorState.isDirty = !!isDirty;
  const warning = getTradeEditorWarningElement();
  if (warning) {
    warning.classList.toggle('hidden', !tradeEditorState.isDirty);
  }
}

function captureTradeEditorSnapshot() {
  const tbody = document.getElementById('trade-table-body');
  if (!tbody) {
    return '[]';
  }
  const rows = Array.from(tbody.querySelectorAll('tr'));
  const normalized = rows.map((row) => {
    const actionSelect = row.querySelector('.trade-action');
    const symbolInput = row.querySelector('.trade-symbol');
    const qtyInput = row.querySelector('.trade-qty');
    const priceInput = row.querySelector('.trade-price');
    return {
      id: row.dataset.tradeId ? String(row.dataset.tradeId) : '',
      action: actionSelect ? actionSelect.value : '',
      symbol: symbolInput ? symbolInput.value : '',
      qty: qtyInput ? qtyInput.value : '',
      price: priceInput ? priceInput.value : '',
    };
  });
  return JSON.stringify(normalized);
}

function refreshTradeEditorDirtyState() {
  const snapshot = captureTradeEditorSnapshot();
  const isDirty = snapshot !== tradeEditorState.initialSnapshot;
  setTradeEditorDirty(isDirty);
  return isDirty;
}

function resetTradeEditorInitialSnapshot() {
  tradeEditorState.initialSnapshot = captureTradeEditorSnapshot();
  setTradeEditorDirty(false);
}

function focusTradeEditorFirstField() {
  const editor = document.getElementById('trade-editor');
  if (!editor) {
    return;
  }
  const field = editor.querySelector('.trade-symbol, .trade-qty, .trade-price, .trade-action');
  if (field && typeof field.focus === 'function') {
    try {
      field.focus({ preventScroll: true });
    } catch (error) {
      field.focus();
    }
  }
}

function setupTradeEditor(trades, dateStr) {
  clearTradeEditorMessages();
  const tbody = document.getElementById('trade-table-body');
  if (!tbody) return;

  tbody.innerHTML = '';
  (trades || []).forEach(trade => {
    tbody.appendChild(createTradeRow(trade));
  });

  const addButton = document.getElementById('add-trade-row');
  if (addButton) {
    addButton.onclick = () => {
      hideTradeEditorSuccess();
      tbody.appendChild(createTradeRow({ action: 'BUY', symbol: '', qty: '', price: '' }));
      updateTradeEmptyState();
      refreshTradeEditorDirtyState();
    };
  }

  const clearButton = document.getElementById('clear-trades');
  if (clearButton) {
    clearButton.onclick = () => {
      hideTradeEditorSuccess();
      clearTrades(dateStr);
    };
  }

  const importInput = document.getElementById('trade-import-input');
  const importButton = document.getElementById('import-trades');
  if (importButton && importInput) {
    importButton.onclick = () => {
      importInput.click();
    };
  }
  if (importInput) {
    importInput.onchange = (event) => handleTradeCsvImport(event, dateStr);
  }

  const exportButton = document.getElementById('export-trades');
  if (exportButton) {
    exportButton.onclick = () => exportTradesToCsv(dateStr);
  }

  updateTradeEmptyState();

  tradeEditorState.unsavedWarning = document.getElementById('trade-unsaved');
  tradeEditorState.currentDate = dateStr;
  resetTradeEditorInitialSnapshot();

  const modal = getModalController();
  if (modal) {
    modal.beforeClose = () => {
      const dirty = refreshTradeEditorDirtyState();
      if (!dirty) {
        return true;
      }
      const confirmClose = window.confirm('You have unsaved changes to these trades. Discard them?');
      if (!confirmClose) {
        focusTradeEditorFirstField();
        return false;
      }
      return true;
    };
  }
}

function createTradeRow(trade) {
  const row = document.createElement('tr');
  row.className = 'border-b border-neutral-800';
  if (trade && trade.id !== undefined && trade.id !== null) {
    row.dataset.tradeId = String(trade.id);
  }

  const markDirty = () => {
    hideTradeEditorSuccess();
    refreshTradeEditorDirtyState();
  };

  const actionCell = document.createElement('td');
  actionCell.className = 'px-2 py-1 border border-neutral-800';
  const actionSelect = document.createElement('select');
  actionSelect.className = 'trade-action bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-neutral-100';
  ['BUY', 'SELL'].forEach(optionValue => {
    const option = document.createElement('option');
    option.value = optionValue;
    option.textContent = optionValue;
    actionSelect.appendChild(option);
  });
  const actionValue = trade && trade.action ? String(trade.action).toUpperCase() : 'BUY';
  actionSelect.value = actionValue;
  actionSelect.addEventListener('change', markDirty);
  actionCell.appendChild(actionSelect);
  row.appendChild(actionCell);

  const symbolCell = document.createElement('td');
  symbolCell.className = 'px-2 py-1 border border-neutral-800';
  const symbolInput = document.createElement('input');
  symbolInput.type = 'text';
  symbolInput.className = 'trade-symbol w-full bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-neutral-100 uppercase';
  symbolInput.value = trade && trade.symbol ? trade.symbol : '';
  symbolInput.autocomplete = 'off';
  symbolInput.spellcheck = false;
  symbolInput.addEventListener('input', markDirty);
  symbolCell.appendChild(symbolInput);
  row.appendChild(symbolCell);

  const qtyCell = document.createElement('td');
  qtyCell.className = 'px-2 py-1 border border-neutral-800 text-right';
  const qtyInput = document.createElement('input');
  qtyInput.type = 'number';
  qtyInput.step = '1';
  qtyInput.min = '0';
  qtyInput.inputMode = 'decimal';
  qtyInput.className = 'trade-qty w-full bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-neutral-100 text-right';
  qtyInput.value = trade && trade.qty !== undefined && trade.qty !== null ? trade.qty : '';
  qtyInput.addEventListener('input', markDirty);
  qtyCell.appendChild(qtyInput);
  row.appendChild(qtyCell);

  const priceCell = document.createElement('td');
  priceCell.className = 'px-2 py-1 border border-neutral-800 text-right';
  const priceInput = document.createElement('input');
  priceInput.type = 'number';
  priceInput.step = '0.01';
  priceInput.min = '0';
  priceInput.inputMode = 'decimal';
  priceInput.className = 'trade-price w-full bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-neutral-100 text-right';
  priceInput.value = trade && trade.price !== undefined && trade.price !== null ? trade.price : '';
  priceInput.addEventListener('input', markDirty);
  priceCell.appendChild(priceInput);
  row.appendChild(priceCell);

  const actionsCell = document.createElement('td');
  actionsCell.className = 'px-2 py-1 border border-neutral-800 text-right';
  const removeButton = document.createElement('button');
  removeButton.type = 'button';
  removeButton.className = 'remove-trade-row btn btn-outline-danger px-2 py-1 text-xs';
  removeButton.textContent = 'Remove';
  removeButton.addEventListener('click', () => {
    hideTradeEditorSuccess();
    row.remove();
    updateTradeEmptyState();
    refreshTradeEditorDirtyState();
  });
  actionsCell.appendChild(removeButton);
  row.appendChild(actionsCell);

  return row;
}

function updateTradeEmptyState() {
  const tbody = document.getElementById('trade-table-body');
  const message = document.getElementById('trade-empty-message');
  if (!tbody || !message) return;
  if (tbody.children.length === 0) {
    message.classList.remove('hidden');
  } else {
    message.classList.add('hidden');
  }
}

function clearTradeEditorMessages() {
  const errorEl = document.getElementById('trade-error');
  if (errorEl) {
    errorEl.textContent = '';
    errorEl.classList.add('hidden');
  }
  hideTradeEditorSuccess();
}

function hideTradeEditorSuccess() {
  const successEl = document.getElementById('trade-success');
  if (successEl) {
    successEl.textContent = '';
    successEl.classList.add('hidden');
  }
}

function showTradeEditorError(message) {
  hideTradeEditorSuccess();
  const errorEl = document.getElementById('trade-error');
  if (errorEl) {
    errorEl.textContent = message;
    errorEl.classList.remove('hidden');
  }
}

function showTradeEditorSuccess(message) {
  const errorEl = document.getElementById('trade-error');
  if (errorEl) {
    errorEl.textContent = '';
    errorEl.classList.add('hidden');
  }
  const successEl = document.getElementById('trade-success');
  if (successEl) {
    successEl.textContent = message;
    successEl.classList.remove('hidden');
  }
}

function parseCsv(text) {
  if (typeof text !== 'string') {
    return [];
  }

  const rows = [];
  let current = '';
  let row = [];
  let inQuotes = false;

  for (let i = 0; i < text.length; i += 1) {
    const char = text[i];
    if (inQuotes) {
      if (char === '"') {
        if (text[i + 1] === '"') {
          current += '"';
          i += 1;
        } else {
          inQuotes = false;
        }
      } else {
        current += char;
      }
    } else if (char === '"') {
      inQuotes = true;
    } else if (char === ',') {
      row.push(current);
      current = '';
    } else if (char === '\r') {
      // Ignore carriage returns
    } else if (char === '\n') {
      row.push(current);
      rows.push(row);
      row = [];
      current = '';
    } else {
      current += char;
    }
  }

  row.push(current);
  rows.push(row);

  return rows.filter((cells) => cells.some((cell) => cell.trim() !== ''));
}

function normalizeNumberString(value) {
  if (typeof value !== 'string') {
    return '';
  }
  return value.replace(/[^0-9.\-]/g, '');
}

function parseTradeCsv(text) {
  const rows = parseCsv(text);
  if (!rows.length) {
    throw new Error('The CSV file is empty.');
  }

  const headerAliases = {
    action: ['action', 'type', 'side'],
    symbol: ['symbol', 'ticker', 'security'],
    qty: ['qty', 'quantity', 'shares', 'volume'],
    price: ['price', 'fill price', 'trade price', 'avg price'],
  };

  const normalizedHeader = rows[0].map((cell) => cell.trim().toLowerCase());
  const columnIndex = {};

  normalizedHeader.forEach((header, index) => {
    Object.entries(headerAliases).forEach(([key, aliases]) => {
      if (columnIndex[key] !== undefined) {
        return;
      }
      if (aliases.includes(header)) {
        columnIndex[key] = index;
      }
    });
  });

  const requiredKeys = ['action', 'symbol', 'qty', 'price'];
  const hasHeader = requiredKeys.every((key) => columnIndex[key] !== undefined);

  if (!hasHeader) {
    if (rows[0].length < requiredKeys.length) {
      throw new Error('CSV rows must include action, symbol, quantity, and price columns.');
    }
    columnIndex.action = 0;
    columnIndex.symbol = 1;
    columnIndex.qty = 2;
    columnIndex.price = 3;
  }

  const dataRows = hasHeader ? rows.slice(1) : rows;

  const trades = [];
  const errors = [];

  dataRows.forEach((cells, rowIndex) => {
    const values = {
      action: columnIndex.action < cells.length ? cells[columnIndex.action] : '',
      symbol: columnIndex.symbol < cells.length ? cells[columnIndex.symbol] : '',
      qty: columnIndex.qty < cells.length ? cells[columnIndex.qty] : '',
      price: columnIndex.price < cells.length ? cells[columnIndex.price] : '',
    };

    const trimmed = {
      action: (values.action || '').trim(),
      symbol: (values.symbol || '').trim(),
      qty: (values.qty || '').trim(),
      price: (values.price || '').trim(),
    };

    if (!trimmed.action && !trimmed.symbol && !trimmed.qty && !trimmed.price) {
      return;
    }

    const rowNumber = hasHeader ? rowIndex + 2 : rowIndex + 1;

    if (!trimmed.symbol) {
      errors.push(`Row ${rowNumber}: Symbol is required.`);
      return;
    }

    if (!trimmed.action) {
      errors.push(`Row ${rowNumber}: Action is required.`);
      return;
    }

    const normalizedAction = trimmed.action.toUpperCase();
    if (normalizedAction !== 'BUY' && normalizedAction !== 'SELL') {
      errors.push(`Row ${rowNumber}: Action must be BUY or SELL.`);
      return;
    }

    if (!trimmed.qty) {
      errors.push(`Row ${rowNumber}: Quantity is required.`);
      return;
    }

    if (!trimmed.price) {
      errors.push(`Row ${rowNumber}: Price is required.`);
      return;
    }

    const qtyValue = parseFloat(normalizeNumberString(trimmed.qty));
    const priceValue = parseFloat(normalizeNumberString(trimmed.price));

    if (!Number.isFinite(qtyValue) || qtyValue <= 0) {
      errors.push(`Row ${rowNumber}: Quantity must be a positive number.`);
      return;
    }

    if (!Number.isFinite(priceValue) || priceValue <= 0) {
      errors.push(`Row ${rowNumber}: Price must be a positive number.`);
      return;
    }

    trades.push({
      action: normalizedAction,
      symbol: trimmed.symbol.toUpperCase(),
      qty: Math.abs(qtyValue),
      price: Math.abs(priceValue),
    });
  });

  if (errors.length) {
    throw new Error(errors.join(' '));
  }

  if (!trades.length) {
    throw new Error('No trades were found in the CSV file.');
  }

  return trades;
}

function applyImportedTrades(trades) {
  const tbody = document.getElementById('trade-table-body');
  if (!tbody) {
    return;
  }

  tbody.innerHTML = '';
  trades.forEach((trade) => {
    tbody.appendChild(
      createTradeRow({
        action: trade.action,
        symbol: trade.symbol,
        qty: trade.qty,
        price: trade.price,
      })
    );
  });

  updateTradeEmptyState();
  refreshTradeEditorDirtyState();
  focusTradeEditorFirstField();
}

function handleTradeCsvImport(event, dateStr) {
  const input = event && event.target ? event.target : null;
  const files = input && input.files ? Array.from(input.files) : [];
  const file = files.length ? files[0] : null;

  if (!file) {
    return;
  }

  clearTradeEditorMessages();

  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = typeof reader.result === 'string' ? reader.result : '';
      const trades = parseTradeCsv(text);
      applyImportedTrades(trades);
      const dateLabel = dateStr || 'this date';
      showTradeEditorSuccess(
        `${trades.length} trade${trades.length === 1 ? '' : 's'} imported. Save to overwrite existing trades for ${dateLabel}.`,
      );
    } catch (error) {
      showTradeEditorError(error && error.message ? error.message : 'Unable to import trades from CSV.');
    } finally {
      input.value = '';
    }
  };
  reader.onerror = () => {
    showTradeEditorError('Failed to read the CSV file. Please try again.');
    input.value = '';
  };
  reader.readAsText(file);
}

function escapeCsvValue(value) {
  const stringValue = value === undefined || value === null ? '' : String(value);
  if (/[",\n\r]/.test(stringValue)) {
    return '"' + stringValue.replace(/"/g, '""') + '"';
  }
  return stringValue;
}

function exportTradesToCsv(dateStr) {
  clearTradeEditorMessages();

  let parsed;
  try {
    parsed = JSON.parse(captureTradeEditorSnapshot());
  } catch (error) {
    showTradeEditorError('Unable to export trades. Try again after making a change.');
    return;
  }

  if (!Array.isArray(parsed)) {
    showTradeEditorError('Unable to export trades.');
    return;
  }

  const rows = [];
  let hasIncomplete = false;

  parsed.forEach((row) => {
    const action = (row.action || 'BUY').toString().toUpperCase();
    const symbol = (row.symbol || '').trim();
    const qty = (row.qty || '').toString().trim();
    const price = (row.price || '').toString().trim();
    const hasAny = symbol || qty || price;
    if (!hasAny) {
      return;
    }
    if (!symbol || !qty || !price) {
      hasIncomplete = true;
      return;
    }

    rows.push([
      action === 'SELL' ? 'SELL' : 'BUY',
      symbol.toUpperCase(),
      qty,
      price,
    ]);
  });

  if (hasIncomplete) {
    showTradeEditorError('Cannot export CSV because some trades are incomplete. Complete or remove them and try again.');
    return;
  }

  if (!rows.length) {
    showTradeEditorError('No trades are available to export. Add trades first.');
    return;
  }

  const csvRows = [
    ['Action', 'Symbol', 'Quantity', 'Price'],
    ...rows,
  ];

  const csvContent = csvRows.map((cells) => cells.map(escapeCsvValue).join(',')).join('\r\n');
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const downloadName = `trades-${(dateStr || 'day').replace(/[^0-9A-Za-z_-]/g, '') || 'day'}.csv`;

  const link = document.createElement('a');
  link.href = url;
  link.download = downloadName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  setTimeout(() => URL.revokeObjectURL(url), 0);

  showTradeEditorSuccess('CSV downloaded.');
}

function saveTrades(dateStr) {
  const modal = getModalController();
  if (!modal) return;
  const tbody = document.getElementById('trade-table-body');
  if (!tbody) return;

  clearTradeEditorMessages();

  const rows = Array.from(tbody.querySelectorAll('tr'));
  const trades = [];
  let hasError = false;

  rows.forEach(row => {
    const actionSelect = row.querySelector('.trade-action');
    const symbolInput = row.querySelector('.trade-symbol');
    const qtyInput = row.querySelector('.trade-qty');
    const priceInput = row.querySelector('.trade-price');

    const symbol = symbolInput ? symbolInput.value.trim() : '';
    const qtyRaw = qtyInput ? qtyInput.value.trim() : '';
    const priceRaw = priceInput ? priceInput.value.trim() : '';
    const isEmpty = !symbol && !qtyRaw && !priceRaw;

    if (isEmpty) {
      row.classList.remove('bg-danger-soft');
      return;
    }

    const qty = parseFloat(qtyRaw);
    const price = parseFloat(priceRaw);
    if (!symbol || Number.isNaN(qty) || Number.isNaN(price) || qty <= 0 || price <= 0) {
      row.classList.add('bg-danger-soft');
      hasError = true;
      return;
    }

    row.classList.remove('bg-danger-soft');
    trades.push({
      id: row.dataset.tradeId ? Number(row.dataset.tradeId) : null,
      symbol: symbol.toUpperCase(),
      action: actionSelect ? actionSelect.value : 'BUY',
      qty: Math.abs(qty),
      price: Math.abs(price),
    });
  });

  if (hasError) {
    showTradeEditorError('Please complete all fields for each trade or remove unused rows.');
    return;
  }

  modal.saving = true;

  fetch('/api/trades/' + dateStr, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ trades }),
  })
    .then(response => {
      if (!response.ok) {
        return response.json().catch(() => ({})).then(data => {
          const message = data && data.detail ? data.detail : 'Failed to save trades.';
          throw new Error(message);
        });
      }
      return response.json();
    })
    .then(data => {
      const savedTrades = data && Array.isArray(data.trades) ? data.trades : [];
      setupTradeEditor(savedTrades, dateStr);
      showTradeEditorSuccess('Trades saved. You can continue adding stocks.');
      modal.shouldReloadOnClose = true;
      updateTradeIndicators(dateStr, savedTrades);
    })
    .catch(err => {
      showTradeEditorError(err.message || 'Failed to save trades.');
    })
    .finally(() => {
      modal.saving = false;
    });
}

function clearTrades(dateStr) {
  if (!dateStr) {
    return;
  }

  const modal = getModalController();
  if (!modal) {
    return;
  }

  const confirmed = window.confirm(`Clear all trades for ${dateStr}? This action cannot be undone.`);
  if (!confirmed) {
    return;
  }

  modal.saving = true;
  clearTradeEditorMessages();

  fetch('/api/trades/' + dateStr, { method: 'DELETE' })
    .then(response => {
      if (!response.ok) {
        return response.json().catch(() => ({})).then(data => {
          const message = data && data.detail ? data.detail : 'Failed to clear trades.';
          throw new Error(message);
        });
      }
      return response.json();
    })
    .then(data => {
      setupTradeEditor([], dateStr);
      showTradeEditorSuccess('All trades cleared for this date.');
      updateTradeIndicators(dateStr, []);
      modal.shouldReloadOnClose = true;
    })
    .catch(err => {
      showTradeEditorError(err && err.message ? err.message : 'Failed to clear trades.');
    })
    .finally(() => {
      modal.saving = false;
    });
}

function updateTradeIndicators(dateStr, trades) {
  const cell = document.querySelector(`[data-day-cell='${dateStr}']`);
  if (!cell) {
    return;
  }
  const trigger = cell.querySelector("button[aria-label='View trades']");
  if (!trigger) {
    return;
  }

  const tradeCount = Array.isArray(trades) ? trades.length : 0;
  trigger.classList.toggle('icon-translucent', tradeCount === 0);

  let badge = trigger.querySelector('.trade-count-badge');
  if (tradeCount > 0) {
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'trade-count-badge absolute -top-1 -right-1 min-w-[1.25rem] rounded-full text-[10px] font-semibold px-1 text-center';
      trigger.appendChild(badge);
    }
    badge.textContent = String(tradeCount);
  } else if (badge) {
    badge.remove();
  }
}

  function openManual(dateStr, realized, unrealized) {
    const modal = getModalController();
    if (!modal) return;

    const normalizedRealized = typeof realized === 'number' && Number.isFinite(realized) ? realized : '';
    const normalizedUnrealized = typeof unrealized === 'number' && Number.isFinite(unrealized) ? unrealized : '';

    modal.title = 'Manual edit ' + dateStr;
    modal.closeLabel = 'Cancel';
    modal.saveLabel = 'Save values';
    modal.saving = false;
    modal.body = `
      <form id="manual-form" class="space-y-3">
        <p class="text-sm text-red-400 hidden" data-manual-error></p>
        <p class="text-sm leading-relaxed text-amber-200 bg-amber-900/40 border border-amber-500/40 rounded px-3 py-2">
          Manual overrides are not recommended when trades are also tracked for this day. The next trade import or recompute
          will overwrite these values and can leave your stock totals mismatched.
        </p>
        <label class="block text-sm space-y-1">
          <span class="text-neutral-300">Realized</span>
          <input type="number" step="0.01" inputmode="decimal" name="realized" value="${normalizedRealized}" class="w-full rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-neutral-100 focus:outline-none focus:ring-1 focus:ring-neutral-500">
        </label>
        <label class="block text-sm space-y-1">
          <span class="text-neutral-300">Unrealized (invested)</span>
          <input type="number" step="0.01" inputmode="decimal" name="unrealized" value="${normalizedUnrealized}" class="w-full rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-neutral-100 focus:outline-none focus:ring-1 focus:ring-neutral-500">
        </label>
      </form>`;
    modal.save = () => {
      const form = document.getElementById('manual-form');
      if (!form) {
        modal.save = null;
        return;
      }

      const errorEl = form.querySelector('[data-manual-error]');
      if (errorEl) {
        errorEl.textContent = '';
        errorEl.classList.add('hidden');
      }

      const fd = new FormData(form);
      modal.saving = true;

      fetch('/api/daily/' + dateStr, { method: 'POST', body: fd })
        .then((response) => {
          if (!response.ok) {
            return response
              .json()
              .catch(() => ({}))
              .then((data) => {
                const message = data && data.detail ? data.detail : 'Failed to save daily values.';
                throw new Error(message);
              });
          }
          return response.json();
        })
        .then(() => {
          modal.saving = false;
          modal.close(true);
          window.location.reload();
        })
        .catch((error) => {
          console.error(error);
          modal.saving = false;
          if (errorEl) {
            errorEl.textContent = error && error.message ? error.message : 'Failed to save daily values.';
            errorEl.classList.remove('hidden');
          }
        });
    };
    modal.open = true;
  }

function escapeHtml(value) {
  return String(value ?? '').replace(/[&<>"']/g, (char) => {
    switch (char) {
      case '&':
        return '&amp;';
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '"':
        return '&quot;';
      case "'":
        return '&#39;';
      default:
        return char;
    }
  });
}

function formatNoteTimestamp(isoString) {
  if (!isoString) {
    return '';
  }
  try {
    const value = new Date(isoString);
    if (Number.isNaN(value.getTime())) {
      return '';
    }
    return value.toLocaleString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  } catch (error) {
    return '';
  }
}

function formatDailySubtitle(dateStr) {
  try {
    const [year, month, day] = dateStr.split('-').map(Number);
    const value = new Date(year, (month || 1) - 1, day || 1);
    return value.toLocaleDateString(undefined, {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  } catch (error) {
    return dateStr;
  }
}

function getIsoWeekStart(year, week) {
  const simple = new Date(year, 0, 1 + (week - 1) * 7);
  const dayOfWeek = simple.getDay() || 7;
  const isoStart = new Date(simple);
  if (dayOfWeek <= 4) {
    isoStart.setDate(simple.getDate() - dayOfWeek + 1);
  } else {
    isoStart.setDate(simple.getDate() + (8 - dayOfWeek));
  }
  isoStart.setHours(0, 0, 0, 0);
  return isoStart;
}

function formatWeeklySubtitle(year, week) {
  try {
    const start = getIsoWeekStart(year, week);
    const end = new Date(start);
    end.setDate(start.getDate() + 6);
    const startLabel = start.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    const endLabel = end.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
    return `Week ${week} • ${startLabel} – ${endLabel}`;
  } catch (error) {
    return `Week ${week}, ${year}`;
  }
}

function formatMonthlySubtitle(year, month) {
  try {
    const value = new Date(year, (month || 1) - 1, 1);
    return value.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
  } catch (error) {
    return `${year}-${String(month).padStart(2, '0')}`;
  }
}

function openNoteEditor(config) {
  const modal = getModalController();
  if (!modal) {
    return;
  }

  const {
    title,
    subtitle,
    fetchUrl,
    saveUrl,
    placeholder,
    onSave,
    closeLabel = 'Cancel',
    saveLabel = 'Save note',
  } = config;

  modal.title = title;
  modal.closeLabel = closeLabel;
  modal.saveLabel = saveLabel;
  modal.saving = false;
  modal.body = '<div class="flex items-center justify-center p-6 text-sm text-neutral-300">Loading note…</div>';
  modal.save = null;
  modal.open = true;

  fetch(fetchUrl)
    .then((response) => {
      if (!response.ok) {
        return response
          .json()
          .catch(() => ({}))
          .then((data) => {
            const message = data && data.detail ? data.detail : 'Failed to load note.';
            throw new Error(message);
          });
      }
      return response.json();
    })
    .then((payload) => {
      const noteText = payload && typeof payload.note === 'string' ? payload.note : '';
      const updatedAt = payload && typeof payload.updated_at === 'string' ? payload.updated_at : '';
      renderNoteEditor(modal, {
        subtitle,
        noteText,
        updatedAt,
        placeholder,
        saveUrl,
        onSave,
        saveLabel,
      });
    })
    .catch((error) => {
      console.error(error);
      const message = error && error.message ? error.message : 'Failed to load note.';
      modal.body = `<p class="text-sm text-danger">${escapeHtml(message)}</p>`;
      modal.closeLabel = 'Close';
      modal.saveLabel = 'Save';
      modal.save = null;
    });
}

function renderNoteEditor(modal, config) {
  const {
    subtitle,
    noteText,
    updatedAt,
    placeholder,
    saveUrl,
    onSave,
    saveLabel,
  } = config;

  const subtitleText = subtitle ? escapeHtml(subtitle) : '';
  const placeholderText = placeholder ? escapeHtml(placeholder) : 'Add your note…';

  modal.saveLabel = saveLabel;
  modal.body = `
    <div class="space-y-4" data-note-editor-root>
      <div class="space-y-1">
        <p class="text-xs uppercase tracking-wide text-neutral-500">Context</p>
        <p class="text-sm text-neutral-300">${subtitleText}</p>
        <p class="text-xs text-neutral-500" data-note-updated-display></p>
      </div>
      <div class="space-y-2">
        <label class="block text-sm text-neutral-300" for="note-field">
          <span class="mb-2 block text-neutral-400">Note</span>
          <textarea id="note-field" data-autofocus class="w-full min-h-[14rem] rounded border border-neutral-700 bg-neutral-900 px-3 py-2 text-neutral-100 focus:outline-none focus-ring-primary" placeholder="${placeholderText}" spellcheck="true"></textarea>
        </label>
        <div class="flex items-center justify-between text-xs text-neutral-500">
          <span>Notes are saved as plain text.</span>
          <span data-note-char-count>0 characters</span>
        </div>
        <p class="text-xs text-warning hidden" data-note-unsaved-warning>Unsaved changes. Save your note to keep it.</p>
      </div>
      <p class="text-sm text-danger hidden" data-note-error></p>
      <div class="flex items-center justify-between border-t border-neutral-800 pt-3">
        <button type="button" class="text-xs text-neutral-400 transition hover:text-neutral-100" data-note-clear>Clear note</button>
        <span class="text-xs text-neutral-500" data-note-updated-display-secondary></span>
      </div>
    </div>
  `;

  window.requestAnimationFrame(() => {
    initializeNoteEditor({
      modal,
      noteText,
      updatedAt,
      saveUrl,
      onSave,
    });
  });
}

function initializeNoteEditor(options) {
  const { modal, noteText, updatedAt, saveUrl, onSave } = options;
  const root = document.querySelector('[data-note-editor-root]');
  if (!root) {
    return;
  }

  const field = root.querySelector('#note-field');
  const counter = root.querySelector('[data-note-char-count]');
  const errorEl = root.querySelector('[data-note-error]');
  const clearButton = root.querySelector('[data-note-clear]');
  const updatedDisplays = root.querySelectorAll('[data-note-updated-display], [data-note-updated-display-secondary]');
  const unsavedWarning = root.querySelector('[data-note-unsaved-warning]');

  let initialValue = typeof noteText === 'string' ? noteText : '';

  const updateDirtyState = () => {
    const currentValue = field ? field.value : '';
    const isDirty = currentValue !== initialValue;
    if (unsavedWarning) {
      unsavedWarning.classList.toggle('hidden', !isDirty);
    }
    return isDirty;
  };

  const updateDisplays = (isoString) => {
    let label = 'Not saved yet';
    if (isoString) {
      const formatted = formatNoteTimestamp(isoString);
      label = formatted ? `Last updated ${formatted}` : `Last updated ${isoString}`;
    }
    updatedDisplays.forEach((element) => {
      if (element) {
        element.textContent = label;
      }
    });
  };

  const updateCounter = () => {
    if (!counter || !field) {
      return;
    }
    const length = field.value.length;
    counter.textContent = `${length} ${length === 1 ? 'character' : 'characters'}`;
  };

  if (field) {
    field.value = noteText;
    try {
      field.focus({ preventScroll: true });
    } catch (error) {
      field.focus();
    }
    const length = noteText.length;
    if (typeof field.setSelectionRange === 'function') {
      try {
        field.setSelectionRange(length, length);
      } catch (error) {
        // ignore selection issues for unsupported inputs
      }
    }
    field.addEventListener('input', () => {
      updateCounter();
      if (errorEl) {
        errorEl.textContent = '';
        errorEl.classList.add('hidden');
      }
      updateDirtyState();
    });
  }

  updateCounter();
  updateDisplays(updatedAt);
  updateDirtyState();

  if (clearButton && field) {
    clearButton.addEventListener('click', () => {
      field.value = '';
      try {
        field.focus({ preventScroll: true });
      } catch (error) {
        field.focus();
      }
      updateCounter();
      updateDirtyState();
    });
  }

  modal.beforeClose = () => {
    const dirty = updateDirtyState();
    if (!dirty) {
      return true;
    }
    const confirmClose = window.confirm('You have unsaved changes to this note. Discard them?');
    if (!confirmClose) {
      if (field) {
        try {
          field.focus({ preventScroll: true });
        } catch (error) {
          field.focus();
        }
      }
      return false;
    }
    return true;
  };

  modal.save = () => {
    if (!field) {
      return;
    }

    if (errorEl) {
      errorEl.textContent = '';
      errorEl.classList.add('hidden');
    }

    const noteValue = field.value;
    modal.saving = true;
    const fd = new FormData();
    fd.append('note', noteValue);

    fetch(saveUrl, { method: 'POST', body: fd })
      .then((response) => {
        if (!response.ok) {
          return response
            .json()
            .catch(() => ({}))
            .then((data) => {
              const message = data && data.detail ? data.detail : 'Failed to save note.';
              throw new Error(message);
            });
        }
        return response.json();
      })
      .then((payload) => {
        modal.saving = false;
        const updatedValue = payload && typeof payload.updated_at === 'string'
          ? payload.updated_at
          : new Date().toISOString();
        if (typeof onSave === 'function') {
          onSave(noteValue, { updatedAt: updatedValue });
        }
        initialValue = noteValue;
        updateDirtyState();
        modal.close(true);
      })
      .catch((error) => {
        console.error(error);
        modal.saving = false;
        if (errorEl) {
          errorEl.textContent = error && error.message ? error.message : 'Failed to save note.';
          errorEl.classList.remove('hidden');
        }
      });
  };
}

function openDailyNote(dateStr) {
  openNoteEditor({
    title: 'Daily note',
    subtitle: formatDailySubtitle(dateStr),
    fetchUrl: '/api/notes/daily/' + dateStr,
    saveUrl: '/api/notes/daily/' + dateStr,
    placeholder: 'Capture highlights from this trading day…',
    onSave: (noteValue, meta) => {
      updateDailyNoteIndicator(dateStr, noteValue, meta && meta.updatedAt);
    },
  });
}

function openWeeklyNote(year, week) {
  openNoteEditor({
    title: 'Weekly note',
    subtitle: formatWeeklySubtitle(year, week),
    fetchUrl: `/api/notes/weekly/${year}/${week}`,
    saveUrl: `/api/notes/weekly/${year}/${week}`,
    placeholder: 'Summarize how the week went…',
    onSave: (noteValue, meta) => {
      updateWeeklyNoteIndicator(year, week, noteValue, meta && meta.updatedAt);
    },
  });
}

function openMonthlyNote(year, month) {
  openNoteEditor({
    title: 'Monthly note',
    subtitle: formatMonthlySubtitle(year, month),
    fetchUrl: `/api/notes/monthly/${year}/${month}`,
    saveUrl: `/api/notes/monthly/${year}/${month}`,
    placeholder: 'Reflect on the month as a whole…',
    onSave: (noteValue, meta) => {
      updateMonthlyNoteIndicator(year, month, noteValue, meta && meta.updatedAt);
    },
  });
}

function getModalController() {
  const modal = window.modalController;
  if (!modal) {
    console.error('Modal controller is not ready yet');
    return null;
  }
  return modal;
}

function updateNoteTrigger(trigger, options = {}) {
  if (!trigger) {
    return false;
  }

  const { noteText, updatedAt, emptyLabel, filledLabel } = options;
  const normalized = typeof noteText === 'string' ? noteText : '';
  const trimmed = normalized.trim();
  const hasNote = trimmed.length > 0;
  const updatedValue = typeof updatedAt === 'string' ? updatedAt : '';

  trigger.dataset.noteText = normalized;
  trigger.dataset.noteUpdated = updatedValue;

  if (typeof emptyLabel === 'string' && typeof filledLabel === 'string') {
    trigger.setAttribute('aria-label', hasNote ? filledLabel : emptyLabel);
  }

  trigger.classList.toggle('has-note', hasNote);
  trigger.classList.toggle('icon-translucent', !hasNote);
  trigger.setAttribute('aria-label', hasNote ? 'Edit weekly note' : 'Add weekly note');
  const tooltipBody = trigger.querySelector('.note-tooltip [data-note-tooltip-body]');
  if (tooltipBody) {
    tooltipBody.textContent = normalized;
  }

  const tooltipUpdated = trigger.querySelector('.note-tooltip [data-note-tooltip-updated]');
  if (tooltipUpdated) {
    if (updatedValue) {
      const formatted = formatNoteTimestamp(updatedValue);
      tooltipUpdated.textContent = formatted ? `Updated ${formatted}` : `Updated ${updatedValue}`;
    } else {
      tooltipUpdated.textContent = 'Not saved yet';
    }
  }

  if (hasNote) {
    trigger.setAttribute('title', normalized);
  } else {
    trigger.removeAttribute('title');
  }

  return hasNote;
}

function updateWeeklyNoteIndicator(year, week, noteText, updatedAt) {
  const selector = `[data-week-year='${year}'][data-week-index='${week}']`;
  const trigger = document.querySelector(selector);
  if (!trigger) {
    return;
  }
  const hasNote = updateNoteTrigger(trigger, {
    noteText,
    updatedAt,
    emptyLabel: 'Add weekly note',
    filledLabel: 'Edit weekly note',
  });
  const svg = trigger.querySelector('svg');
  if (svg) {
    svg.classList.toggle('text-amber-400', hasNote);
  }
}

function updateDailyNoteIndicator(dateStr, noteText, updatedAt) {
  const cell = document.querySelector(`[data-day-cell='${dateStr}']`);
  if (!cell) {
    return;
  }
  const trigger = cell.querySelector('.note-trigger');
  if (!trigger) {
    return;
  }
  updateNoteTrigger(trigger, {
    noteText,
    updatedAt,
    emptyLabel: 'Add daily note',
    filledLabel: 'Edit daily note',
  });
}

function updateMonthlyNoteIndicator(year, month, noteText, updatedAt) {
  const selector = `[data-month-key='${year}-${String(month).padStart(2, '0')}']`;
  const trigger = document.querySelector(selector);
  if (!trigger) {
    return;
  }
  const normalized = typeof noteText === 'string' ? noteText : '';
  const hasNote = normalized.trim().length > 0;
  trigger.dataset.noteText = normalized;
  trigger.dataset.noteUpdated = updatedAt || '';
  trigger.classList.toggle('has-note', hasNote);
  trigger.classList.toggle('icon-translucent', !hasNote);
  trigger.setAttribute('aria-label', hasNote ? 'Edit monthly note' : 'Add monthly note');
  const tooltipBody = trigger.querySelector('.note-tooltip [data-note-tooltip-body]');
  if (tooltipBody) {
    tooltipBody.textContent = normalized;
  }
}

document.querySelectorAll('.note-trigger').forEach((trigger) => {
  updateNoteTrigger(trigger, {
    noteText: trigger.dataset.noteText || '',
    updatedAt: trigger.dataset.noteUpdated || '',
    emptyLabel: trigger.dataset.noteLabelEmpty,
    filledLabel: trigger.dataset.noteLabelFilled,
  });
});
</script>
{% endblock %}
